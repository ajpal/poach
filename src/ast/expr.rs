use crate::{core::ResolvedCall, *};
use ordered_float::OrderedFloat;
use std::{fmt::Display, hash::Hasher};

#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone)]
pub enum Literal {
    Int(i64),
    Float(OrderedFloat<f64>),
    String(String),
    Bool(bool),
    Unit,
}

macro_rules! impl_from {
    ($ctor:ident($t:ty)) => {
        impl From<Literal> for $t {
            fn from(literal: Literal) -> Self {
                match literal {
                    Literal::$ctor(t) => t,
                    #[allow(unreachable_patterns)]
                    _ => panic!("Expected {}, got {literal}", stringify!($ctor)),
                }
            }
        }

        impl From<$t> for Literal {
            fn from(t: $t) -> Self {
                Literal::$ctor(t)
            }
        }
    };
}

impl_from!(Int(i64));
impl_from!(Float(OrderedFloat<f64>));
impl_from!(String(String));

impl Display for Literal {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self {
            Literal::Int(i) => Display::fmt(i, f),
            Literal::Float(n) => {
                // need to display with decimal if there is none
                let str = n.to_string();
                if let Ok(_num) = str.parse::<i64>() {
                    write!(f, "{}.0", str)
                } else {
                    write!(f, "{}", str)
                }
            }
            Literal::Bool(b) => Display::fmt(b, f),
            Literal::String(s) => write!(f, "\"{}\"", s),
            Literal::Unit => write!(f, "()"),
        }
    }
}

#[derive(Debug, Clone)]
pub struct ResolvedVar {
    pub name: String,
    pub sort: ArcSort,
    /// Is this a reference to a global variable?
    /// After the `remove_globals` pass, this should be `false`.
    ///
    /// NB: we distinguish between a global reference and a global binding.
    /// The current implementation of `Eq` and `Hash` does not take this field
    /// into consideration.
    /// Overall, the definition of equality between two ResolvedVars is dicey.
    pub is_global_ref: bool,
}

impl PartialEq for ResolvedVar {
    fn eq(&self, other: &Self) -> bool {
        self.name == other.name && self.sort.name() == other.sort.name()
    }
}

impl Eq for ResolvedVar {}

impl Hash for ResolvedVar {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.name.hash(state);
        self.sort.name().hash(state);
    }
}

impl Display for ResolvedVar {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.name)
    }
}

pub type Expr = GenericExpr<String, String>;
/// A generated expression is an expression that is generated by the system
/// and does not have annotations.
pub(crate) type ResolvedExpr = GenericExpr<ResolvedCall, ResolvedVar>;
/// A [`MappedExpr`] arises naturally when you want a mapping between an expression
/// and its flattened form. It records this mapping by annotating each `Head`
/// with a `Leaf`, which it maps to in the flattened form.
/// A useful operation on `MappedExpr`s is [`MappedExpr::get_corresponding_var_or_lit``].
pub(crate) type MappedExpr<Head, Leaf> = GenericExpr<CorrespondingVar<Head, Leaf>, Leaf>;

impl ResolvedExpr {
    pub fn output_type(&self) -> ArcSort {
        match self {
            ResolvedExpr::Lit(_, lit) => sort::literal_sort(lit),
            ResolvedExpr::Var(_, resolved_var) => resolved_var.sort.clone(),
            ResolvedExpr::Call(_, resolved_call, _) => resolved_call.output().clone(),
        }
    }

    pub(crate) fn get_global_var(&self) -> Option<ResolvedVar> {
        match self {
            ResolvedExpr::Var(_, v) if v.is_global_ref => Some(v.clone()),
            _ => None,
        }
    }
}

#[macro_export]
macro_rules! call {
    ($func:expr, $args:expr) => {
        $crate::ast::GenericExpr::Call($crate::span!(), $func.into(), $args.into_iter().collect())
    };
}

#[macro_export]
macro_rules! lit {
    ($lit:expr) => {
        $crate::ast::GenericExpr::Lit($crate::span!(), $lit.into())
    };
}

#[macro_export]
macro_rules! var {
    ($var:expr) => {
        $crate::ast::GenericExpr::Var($crate::span!(), $var.into())
    };
}

// Rust macro annoyance; see stackoverflow.com/questions/26731243/how-do-i-use-a-macro-across-module-files
pub use {call, lit, var};
